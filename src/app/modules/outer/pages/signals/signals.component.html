<div class="component-directives container"> <!--TODO Implementar la lógica de los signals -->
  <div class="row">
    <div class="col-3">
      <div class="stepper-wrapper">
        <h3 class="mt-5 px-5">Contenido</h3>
        <ul class="stepper list-unstyled">
          <li class="step"
              *ngFor="let step of steps"
              [class.active]="activeStep === step.id"
              (click)="scrollToSection(step.id)"
          >
            <div class="step-icon bg-primary text-white">{{ step.number }}</div>
            <div class="step-label">{{ step.label }}</div>
          </li>
        </ul>
      </div>
    </div>
    <div class="col-9">
      <h1 class="mt-4 mb-4">Signals</h1>
      <!--WHATSECTION-->
      <section #sectionRef id="whatSection" class="bg-light text-dark directives-section">
        <h3 class="mb-4">What are Signals?</h3>
        <p>
          Signals are a new reactivity primitive in Angular that allow you to manage and react to state changes in a more efficient way.
          Un signal es un contenedor reactivo para un valor (puede ser primitivo, objeto, array, etc) que notifica cuando su valor cambia.
        </p>
        <p>
          They provide a way to create reactive data sources that can be observed and updated, enabling fine-grained reactivity in your applications.
        </p>
      </section>
      <!--MAINMETHODSSECTION-->
      <section #sectionRef id="mainMethodsSection" class="bg-light text-dark directives-section">
        <h3 class="mb-4">1. Métodos principales de un Signal</h3>
        <p>Cuando creas un signal: </p>

        <pre ngNonBindable class="card bg-dark text-white">
          <code class="language-typescript">
            import &#123; signal &#125; from '@angular/core';

            const counter = signal(0);
          </code>
        </pre>

        <h5>1.1. <code>()</code> — Accessor (lector del valor actual) </h5>
          <p>Tipo: <code>() => T</code></p>
          <ul>
            <li>Es la forma de leer el valor del signal.</li>
            <li>Se invoca como una función, no como una propiedad.</li>
          </ul>
        <pre ngNonBindable class="card bg-dark text-white">
          <code class="language-typescript">
            console.log(counter()); // imprime 0
          </code>
        </pre>

        <h5>1.2. <code>.set(value: T)</code> — Mutator (asignación directa)</h5>
          <p>Tipo: <code>(newValue: T) => void</code></p>
          <ul>
            <li>Cambia el valor del signal asignando un nuevo valor.</li>
            <li>Angular notificará automáticamente a todos los <code>computed()</code> y <code>effect()</code> dependientes que deben recalcularse.</li>
          </ul>
        <pre ngNonBindable class="card bg-dark text-white">
          <code class="language-typescript">
            counter.set(10);
            console.log(counter()); // imprime 10
          </code>
        </pre>

        <h5>1.3. <code>.update(updaterFn: (value: T) => T)</code> — Mutator (actualización basada en el valor actual)</h5>
          <p>Tipo: <code>(updater: (currentValue: T) => T) => void</code></p>
          <ul>
            <li>Permite modificar el valor en función del valor actual.</li>
            <li>Es muy útil para operaciones incrementales o acumulativas.</li>
          </ul>
          <pre class="card bg-dark p-3">
            <code class="language-typescript">
              counter.update(value =&gt; value + 1);
              console.log(counter()); // imprime 11
            </code>
          </pre>

        <h5>1.4. <code>.mutate(mutatorFn: (value: T) => void)</code> — Mutator para objetos o arrays (modificación in place)</h5>
          <p>Tipo: <code>(mutator: (currentValue: T) => void) => void</code></p>
          <ul>
            <li>Permite mutar directamente objetos o arrays sin reemplazarlos por completo.</li>
            <li>Angular detecta los cambios y los propaga automáticamente.</li>
          </ul>
        <pre ngNonBindable class="card bg-dark text-white">
          <code class="language-typescript">
            const user = signal(&#123; name: 'Ana', age: 25 &#125;);

            user.mutate(u => u.age++);

            console.log(user()); // &#123; name: 'Ana', age: 26 &#125;
          </code>
        </pre>

      </section>

      <!--COMPLEMENTARYMETHODSSECTION-->
      <section #sectionRef id="complementaryMethodsSection" class="bg-light text-dark directives-section">
        <h3 class="mb-4">2. Métodos complementarios de lectura y control</h3>
        <p>Además de los métodos principales, los signals también ofrecen métodos complementarios para facilitar la lectura y el control de su estado.</p>

        <h5>2.1. <code>.asReadonly()</code> — Lector (solo lectura)</h5>
          <p>Tipo: <code>() =&gt; ReadonlySignal&lt;T&gt; </code></p>
          <ul>
            <li>Devuelve una versión solo de lectura del signal, para exponerlo públicamente sin permitir que otros lo modifiquen.</li>
          </ul>
        <pre ngNonBindable class="card bg-dark text-white">
          <code class="language-typescript">
            const _count = signal(0);
            export const count = _count.asReadonly();
          </code>
        </pre>

        <h5>2.2. <code>.peek()</code> (nuevo en Angular 17+ y parte de Angular 20)</h5>
          <p>Tipo: <code>() =&gt; T; </code></p>
          <ul>
            <li>Devuelve el valor actual sin registrar dependencia reactiva.</li>
            <li>Ideal cuando quieres leer un signal dentro de un <code>computed()</code> o <code>effect()</code> sin que ese signal dispare re-ejecuciones.</li>
          </ul>
        <pre ngNonBindable class="card bg-dark text-white">
          <code class="language-typescript">
            effect(() =&gt; &#123;
              console.log('El contador es', counter.peek());
              // No reacciona si counter cambia
            &#125;);
          </code>
        </pre>
      </section>

      <!--OTHERHELPERSSECTION-->
      <section #sectionRef id="otherHelpersSection" class="bg-light text-dark directives-section">
        <h3 class="mb-4">3. Otros helpers relacionados con Signals</h3>

        <h5>3.1. <code>computed(() => …)</code> </h5>
          <p>Tipo: <code>&lt;T&gt;(computeFn: () =&gt; T) =&gt; ComputedSignal&lt;T&gt;</code></p>
          <ul>
            <li>Un computed signal (o señal derivada) es un valor calculado automáticamente a partir de uno o más signals.</li>
            <li>Cada vez que alguno de los signals dependientes cambia, el <code>computed()</code> se recalcula automáticamente.</li>
            <li>Angular rastrea automáticamente qué signals se leen dentro del <code>computed()</code>.</li>
            <li>Cuando alguno cambia, recalcula el valor y notifica a quien lo use.</li>
          </ul>
        <pre ngNonBindable class="card bg-dark text-white">
          <code class="language-typescript">
            import &#123; signal, computed &#125; from '@angular/core';

            const count = signal(1);
            const double = computed(() =&gt; count() * 2);
          </code>
        </pre>

        <h5>3.2. <code>effect(() => …)</code> </h5>
          <p>Tipo: <code>&lt;T&gt;(computeFn: () =&gt; T) =&gt; ComputedSignal&lt;T&gt;</code></p>
          <ul>
            <li>Un computed signal (o señal derivada) es un valor calculado automáticamente a partir de uno o más signals.</li>
            <li>Cada vez que alguno de los signals dependientes cambia, el <code>computed()</code> se recalcula automáticamente.</li>
            <li>Angular rastrea automáticamente qué signals se leen dentro del <code>computed()</code>.</li>
            <li>Cuando alguno cambia, recalcula el valor y notifica a quien lo use.</li>
          </ul>
        <pre ngNonBindable class="card bg-dark text-white">
          <code class="language-typescript">
            import &#123; signal, computed &#125; from '@angular/core';

            const count = signal(1);
            const double = computed(() =&gt; count() * 2);
          </code>
        </pre>

        <h5>3.3. <code>untracked(() => …)</code> </h5>
          <p>Tipo: <code>&lt;T&gt;(computeFn: () =&gt; T) =&gt; ComputedSignal&lt;T&gt;</code></p>
          <ul>
            <li>Un computed signal (o señal derivada) es un valor calculado automáticamente a partir de uno o más signals.</li>
            <li>Cada vez que alguno de los signals dependientes cambia, el <code>computed()</code> se recalcula automáticamente.</li>
            <li>Angular rastrea automáticamente qué signals se leen dentro del <code>computed()</code>.</li>
            <li>Cuando alguno cambia, recalcula el valor y notifica a quien lo use.</li>
          </ul>
        <pre ngNonBindable class="card bg-dark text-white">
          <code class="language-typescript">
            import &#123; signal, computed &#125; from '@angular/core';

            const count = signal(1);
            const double = computed(() =&gt; count() * 2);
          </code>
        </pre>

        <h5>3.4. <code>toSignal(observable)</code> </h5>
          <p>Tipo: <code>&lt;T&gt;(computeFn: () =&gt; T) =&gt; ComputedSignal&lt;T&gt;</code></p>
          <ul>
            <li>Un computed signal (o señal derivada) es un valor calculado automáticamente a partir de uno o más signals.</li>
            <li>Cada vez que alguno de los signals dependientes cambia, el <code>computed()</code> se recalcula automáticamente.</li>
            <li>Angular rastrea automáticamente qué signals se leen dentro del <code>computed()</code>.</li>
            <li>Cuando alguno cambia, recalcula el valor y notifica a quien lo use.</li>
          </ul>
        <pre ngNonBindable class="card bg-dark text-white">
          <code class="language-typescript">
            import &#123; signal, computed &#125; from '@angular/core';

            const count = signal(1);
            const double = computed(() =&gt; count() * 2);
          </code>
        </pre>

        <h5>3.5. <code>linkedSignal()</code> (nuevo en Angular 20) </h5>
          <p>Tipo: <code>&lt;T&gt;(computeFn: () =&gt; T) =&gt; ComputedSignal&lt;T&gt;</code></p>
          <ul>
            <li>Un computed signal (o señal derivada) es un valor calculado automáticamente a partir de uno o más signals.</li>
            <li>Cada vez que alguno de los signals dependientes cambia, el <code>computed()</code> se recalcula automáticamente.</li>
            <li>Angular rastrea automáticamente qué signals se leen dentro del <code>computed()</code>.</li>
            <li>Cuando alguno cambia, recalcula el valor y notifica a quien lo use.</li>
          </ul>
        <pre ngNonBindable class="card bg-dark text-white">
          <code class="language-typescript">
            import &#123; signal, computed &#125; from '@angular/core';

            const count = signal(1);
            const double = computed(() =&gt; count() * 2);
          </code>
        </pre>

      </section>

    </div>
  </div>
</div>

